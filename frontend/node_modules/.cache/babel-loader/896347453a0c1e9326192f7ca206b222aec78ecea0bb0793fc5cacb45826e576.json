{"ast":null,"code":"import axios from \"axios\";\n\n// --- CONFIGURATION ---\n// Set this to your backend's URL (e.g., http://localhost:8001)\nconst BACKEND_URL = \"http://localhost:8001\";\n// ---\n\n/**\r\n * Performs a vector search by calling the backend's /knowledge_search endpoint.\r\n * This function handles pure database retrieval.\r\n * @param {string} query The user's question.\r\n * @returns {Promise<Array<object>>} A promise that resolves to an array of result objects\r\n * (e.g., [{ problem, cause, steps, distance }, ...]).\r\n */\nexport const searchKnowledge = async query => {\n  try {\n    var _res$data;\n    // This is the vector search endpoint, expected to return structured JSON\n    const res = await axios.get(`${BACKEND_URL}/knowledge_search?query=${encodeURIComponent(query)}&n_results=3`);\n    const results = ((_res$data = res.data) === null || _res$data === void 0 ? void 0 : _res$data.results) || [];\n    if (results.length > 0) {\n      console.log(`üîç Found ${results.length} raw vector items.`);\n    }\n    return results;\n  } catch (error) {\n    console.error(\"‚ùå Error fetching knowledge:\", error);\n    // Return a structured error message if the backend is unreachable\n    return [{\n      problem: \"Error\",\n      cause: \"Could not reach knowledge base or backend service.\",\n      steps: error.message,\n      distance: 1.0\n    }];\n  }\n};\n\n/**\r\n * Stores the chat log entry in the backend database.\r\n * This calls the Flask endpoint /store_log\r\n * @param {string} expertId - The ID of the technician.\r\n * @param {string} userQuery - The user's original query.\r\n * @param {Array<object>} searchResults - The structured array of results that were shown.\r\n */\nexport async function persistLog(expertId, userQuery, searchResults) {\n  if (!expertId) return false;\n\n  // Serialize the structured results into a readable string for the database log\n  let aiResponseText = \"No relevant steps found.\";\n  if (searchResults && searchResults.length > 0) {\n    aiResponseText = searchResults.map((r, i) => {\n      // FIX: Safely convert distance to a number before calling toFixed\n      const distance = parseFloat(r.distance);\n      const distanceText = !isNaN(distance) ? distance.toFixed(4) : 'N/A';\n      return `--- Match ${i + 1} (Distance: ${distanceText}) ---\\nProblem: ${r.problem}\\nCause: ${r.cause}\\nSteps: ${r.steps}`;\n    }).join('\\n\\n');\n  }\n  try {\n    const logId = crypto.randomUUID();\n    const logData = {\n      expert_id: expertId,\n      user_query: userQuery,\n      ai_response: aiResponseText,\n      // The serialized search result\n      status: \"completed\",\n      timestamp: new Date().toISOString(),\n      log_id: logId\n    };\n\n    // This is the correct logging endpoint for the Flask service\n    await axios.post(`${BACKEND_URL}/store_log`, logData);\n    return true;\n  } catch (err) {\n    console.error(\"Error saving log:\", err.response ? err.response.data : err.message);\n    return false;\n  }\n}","map":{"version":3,"names":["axios","BACKEND_URL","searchKnowledge","query","_res$data","res","get","encodeURIComponent","results","data","length","console","log","error","problem","cause","steps","message","distance","persistLog","expertId","userQuery","searchResults","aiResponseText","map","r","i","parseFloat","distanceText","isNaN","toFixed","join","logId","crypto","randomUUID","logData","expert_id","user_query","ai_response","status","timestamp","Date","toISOString","log_id","post","err","response"],"sources":["C:/Users/Hari/OneDrive/Desktop/elevator_project/frontend/src/api.js"],"sourcesContent":["import axios from \"axios\";\r\n\r\n// --- CONFIGURATION ---\r\n// Set this to your backend's URL (e.g., http://localhost:8001)\r\nconst BACKEND_URL = \"http://localhost:8001\"; \r\n// ---\r\n\r\n/**\r\n * Performs a vector search by calling the backend's /knowledge_search endpoint.\r\n * This function handles pure database retrieval.\r\n * @param {string} query The user's question.\r\n * @returns {Promise<Array<object>>} A promise that resolves to an array of result objects\r\n * (e.g., [{ problem, cause, steps, distance }, ...]).\r\n */\r\nexport const searchKnowledge = async (query) => {\r\n    try {\r\n        // This is the vector search endpoint, expected to return structured JSON\r\n        const res = await axios.get(`${BACKEND_URL}/knowledge_search?query=${encodeURIComponent(query)}&n_results=3`);\r\n        const results = res.data?.results || [];\r\n        \r\n        if (results.length > 0) {\r\n            console.log(`üîç Found ${results.length} raw vector items.`);\r\n        }\r\n        return results; \r\n    } catch (error) {\r\n        console.error(\"‚ùå Error fetching knowledge:\", error);\r\n        // Return a structured error message if the backend is unreachable\r\n        return [{ problem: \"Error\", cause: \"Could not reach knowledge base or backend service.\", steps: error.message, distance: 1.0 }]; \r\n    }\r\n};\r\n\r\n/**\r\n * Stores the chat log entry in the backend database.\r\n * This calls the Flask endpoint /store_log\r\n * @param {string} expertId - The ID of the technician.\r\n * @param {string} userQuery - The user's original query.\r\n * @param {Array<object>} searchResults - The structured array of results that were shown.\r\n */\r\nexport async function persistLog(expertId, userQuery, searchResults) {\r\n    if (!expertId) return false; \r\n\r\n    // Serialize the structured results into a readable string for the database log\r\n    let aiResponseText = \"No relevant steps found.\";\r\n    if (searchResults && searchResults.length > 0) {\r\n        aiResponseText = searchResults.map((r, i) => {\r\n            // FIX: Safely convert distance to a number before calling toFixed\r\n            const distance = parseFloat(r.distance); \r\n            const distanceText = !isNaN(distance) ? distance.toFixed(4) : 'N/A';\r\n\r\n            return `--- Match ${i+1} (Distance: ${distanceText}) ---\\nProblem: ${r.problem}\\nCause: ${r.cause}\\nSteps: ${r.steps}`;\r\n        }).join('\\n\\n');\r\n    }\r\n    \r\n    try {\r\n        const logId = crypto.randomUUID(); \r\n        const logData = {\r\n            expert_id: expertId,\r\n            user_query: userQuery,\r\n            ai_response: aiResponseText, // The serialized search result\r\n            status: \"completed\",\r\n            timestamp: new Date().toISOString(),\r\n            log_id: logId,\r\n        };\r\n        \r\n        // This is the correct logging endpoint for the Flask service\r\n        await axios.post(`${BACKEND_URL}/store_log`, logData);\r\n        return true;\r\n\r\n    } catch (err) {\r\n        console.error(\"Error saving log:\", err.response ? err.response.data : err.message);\r\n        return false;\r\n    }\r\n}"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;;AAEzB;AACA;AACA,MAAMC,WAAW,GAAG,uBAAuB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,eAAe,GAAG,MAAOC,KAAK,IAAK;EAC5C,IAAI;IAAA,IAAAC,SAAA;IACA;IACA,MAAMC,GAAG,GAAG,MAAML,KAAK,CAACM,GAAG,CAAC,GAAGL,WAAW,2BAA2BM,kBAAkB,CAACJ,KAAK,CAAC,cAAc,CAAC;IAC7G,MAAMK,OAAO,GAAG,EAAAJ,SAAA,GAAAC,GAAG,CAACI,IAAI,cAAAL,SAAA,uBAARA,SAAA,CAAUI,OAAO,KAAI,EAAE;IAEvC,IAAIA,OAAO,CAACE,MAAM,GAAG,CAAC,EAAE;MACpBC,OAAO,CAACC,GAAG,CAAC,YAAYJ,OAAO,CAACE,MAAM,oBAAoB,CAAC;IAC/D;IACA,OAAOF,OAAO;EAClB,CAAC,CAAC,OAAOK,KAAK,EAAE;IACZF,OAAO,CAACE,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;IACnD;IACA,OAAO,CAAC;MAAEC,OAAO,EAAE,OAAO;MAAEC,KAAK,EAAE,oDAAoD;MAAEC,KAAK,EAAEH,KAAK,CAACI,OAAO;MAAEC,QAAQ,EAAE;IAAI,CAAC,CAAC;EACnI;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAeC,UAAUA,CAACC,QAAQ,EAAEC,SAAS,EAAEC,aAAa,EAAE;EACjE,IAAI,CAACF,QAAQ,EAAE,OAAO,KAAK;;EAE3B;EACA,IAAIG,cAAc,GAAG,0BAA0B;EAC/C,IAAID,aAAa,IAAIA,aAAa,CAACZ,MAAM,GAAG,CAAC,EAAE;IAC3Ca,cAAc,GAAGD,aAAa,CAACE,GAAG,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;MACzC;MACA,MAAMR,QAAQ,GAAGS,UAAU,CAACF,CAAC,CAACP,QAAQ,CAAC;MACvC,MAAMU,YAAY,GAAG,CAACC,KAAK,CAACX,QAAQ,CAAC,GAAGA,QAAQ,CAACY,OAAO,CAAC,CAAC,CAAC,GAAG,KAAK;MAEnE,OAAO,aAAaJ,CAAC,GAAC,CAAC,eAAeE,YAAY,mBAAmBH,CAAC,CAACX,OAAO,YAAYW,CAAC,CAACV,KAAK,YAAYU,CAAC,CAACT,KAAK,EAAE;IAC1H,CAAC,CAAC,CAACe,IAAI,CAAC,MAAM,CAAC;EACnB;EAEA,IAAI;IACA,MAAMC,KAAK,GAAGC,MAAM,CAACC,UAAU,CAAC,CAAC;IACjC,MAAMC,OAAO,GAAG;MACZC,SAAS,EAAEhB,QAAQ;MACnBiB,UAAU,EAAEhB,SAAS;MACrBiB,WAAW,EAAEf,cAAc;MAAE;MAC7BgB,MAAM,EAAE,WAAW;MACnBC,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;MACnCC,MAAM,EAAEX;IACZ,CAAC;;IAED;IACA,MAAMhC,KAAK,CAAC4C,IAAI,CAAC,GAAG3C,WAAW,YAAY,EAAEkC,OAAO,CAAC;IACrD,OAAO,IAAI;EAEf,CAAC,CAAC,OAAOU,GAAG,EAAE;IACVlC,OAAO,CAACE,KAAK,CAAC,mBAAmB,EAAEgC,GAAG,CAACC,QAAQ,GAAGD,GAAG,CAACC,QAAQ,CAACrC,IAAI,GAAGoC,GAAG,CAAC5B,OAAO,CAAC;IAClF,OAAO,KAAK;EAChB;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}