{"ast":null,"code":"import axios from \"axios\";\n\n// --- CONFIGURATION ---\nconst BACKEND_URL = \"http://localhost:8001\";\n// ---\n\n/**\r\n * Performs vector search from Flask backend.\r\n */\nexport const searchKnowledge = async (query, elevatorId = \"\") => {\n  try {\n    var _res$data;\n    let url = `${BACKEND_URL}/knowledge_search?query=${encodeURIComponent(query)}&n_results=3`;\n    if (elevatorId && elevatorId.trim() !== \"\") {\n      url += `&elevator_id=${encodeURIComponent(elevatorId.trim())}`;\n    }\n    const res = await axios.get(url);\n    const results = ((_res$data = res.data) === null || _res$data === void 0 ? void 0 : _res$data.results) || [];\n    if (results.length > 0) {\n      console.log(`üîç Found ${results.length} results${elevatorId ? ` for Elevator ${elevatorId}` : \"\"}.`);\n    } else {\n      console.log(\"‚ÑπÔ∏è No relevant results found.\");\n    }\n    return results;\n  } catch (error) {\n    console.error(\"‚ùå Error fetching knowledge from backend:\", error);\n    return [{\n      problem: \"Error\",\n      cause: \"Could not reach knowledge base or backend service.\",\n      steps: error.message || \"Server unreachable or misconfigured.\",\n      distance: 1.0\n    }];\n  }\n};\n\n/**\r\n * Persists technician log to backend.\r\n */\nexport async function persistLog(expertId, userQuery, searchResults, elevatorId = \"\") {\n  if (!expertId) {\n    console.warn(\"‚ö†Ô∏è No expert ID provided ‚Äî skipping log persistence.\");\n    return false;\n  }\n  let aiResponseText = \"No relevant steps found.\";\n  if (searchResults && searchResults.length > 0) {\n    aiResponseText = searchResults.map((r, i) => {\n      const distance = parseFloat(r.distance);\n      const distanceText = !isNaN(distance) ? distance.toFixed(4) : \"N/A\";\n      return `--- Match ${i + 1} (Distance: ${distanceText}) ---\\n` + `Problem: ${r.problem}\\n` + `Cause: ${r.cause}\\n` + `Steps: ${r.steps}`;\n    }).join(\"\\n\\n\");\n  }\n  try {\n    const logId = crypto.randomUUID();\n    const logData = {\n      expert_id: expertId,\n      elevator_id: elevatorId || \"All\",\n      user_query: userQuery,\n      ai_response: aiResponseText,\n      status: \"completed\",\n      timestamp: new Date().toISOString(),\n      log_id: logId\n    };\n    await axios.post(`${BACKEND_URL}/store_log`, logData);\n    console.log(`üü¢ Log stored successfully${elevatorId ? ` for Elevator ${elevatorId}` : \"\"}.`);\n    return true;\n  } catch (err) {\n    console.error(\"‚ùå Error saving log:\", err.response ? err.response.data : err.message);\n    return false;\n  }\n}\n\n/**\r\n * ‚úÖ NEW: Conversational AI Chat via Ollama (/chat endpoint)\r\n * Sends conversation history to backend for natural, human-like responses.\r\n */\nexport const chatWithAI = async messages => {\n  try {\n    var _res$data2;\n    const res = await axios.post(`${BACKEND_URL}/chat`, {\n      messages\n    });\n    return ((_res$data2 = res.data) === null || _res$data2 === void 0 ? void 0 : _res$data2.response) || \"No response received from AI.\";\n  } catch (error) {\n    console.error(\"‚ùå Chat API error:\", error);\n    return \"AI is currently unavailable.\";\n  }\n};","map":{"version":3,"names":["axios","BACKEND_URL","searchKnowledge","query","elevatorId","_res$data","url","encodeURIComponent","trim","res","get","results","data","length","console","log","error","problem","cause","steps","message","distance","persistLog","expertId","userQuery","searchResults","warn","aiResponseText","map","r","i","parseFloat","distanceText","isNaN","toFixed","join","logId","crypto","randomUUID","logData","expert_id","elevator_id","user_query","ai_response","status","timestamp","Date","toISOString","log_id","post","err","response","chatWithAI","messages","_res$data2"],"sources":["C:/Users/Hari/OneDrive/Desktop/elevator_project/frontend/src/api.js"],"sourcesContent":["import axios from \"axios\";\r\n\r\n// --- CONFIGURATION ---\r\nconst BACKEND_URL = \"http://localhost:8001\";\r\n// ---\r\n\r\n/**\r\n * Performs vector search from Flask backend.\r\n */\r\nexport const searchKnowledge = async (query, elevatorId = \"\") => {\r\n  try {\r\n    let url = `${BACKEND_URL}/knowledge_search?query=${encodeURIComponent(query)}&n_results=3`;\r\n    if (elevatorId && elevatorId.trim() !== \"\") {\r\n      url += `&elevator_id=${encodeURIComponent(elevatorId.trim())}`;\r\n    }\r\n\r\n    const res = await axios.get(url);\r\n    const results = res.data?.results || [];\r\n    if (results.length > 0) {\r\n      console.log(`üîç Found ${results.length} results${elevatorId ? ` for Elevator ${elevatorId}` : \"\"}.`);\r\n    } else {\r\n      console.log(\"‚ÑπÔ∏è No relevant results found.\");\r\n    }\r\n    return results;\r\n\r\n  } catch (error) {\r\n    console.error(\"‚ùå Error fetching knowledge from backend:\", error);\r\n    return [{\r\n      problem: \"Error\",\r\n      cause: \"Could not reach knowledge base or backend service.\",\r\n      steps: error.message || \"Server unreachable or misconfigured.\",\r\n      distance: 1.0\r\n    }];\r\n  }\r\n};\r\n\r\n/**\r\n * Persists technician log to backend.\r\n */\r\nexport async function persistLog(expertId, userQuery, searchResults, elevatorId = \"\") {\r\n  if (!expertId) {\r\n    console.warn(\"‚ö†Ô∏è No expert ID provided ‚Äî skipping log persistence.\");\r\n    return false;\r\n  }\r\n\r\n  let aiResponseText = \"No relevant steps found.\";\r\n  if (searchResults && searchResults.length > 0) {\r\n    aiResponseText = searchResults.map((r, i) => {\r\n      const distance = parseFloat(r.distance);\r\n      const distanceText = !isNaN(distance) ? distance.toFixed(4) : \"N/A\";\r\n      return (\r\n        `--- Match ${i + 1} (Distance: ${distanceText}) ---\\n` +\r\n        `Problem: ${r.problem}\\n` +\r\n        `Cause: ${r.cause}\\n` +\r\n        `Steps: ${r.steps}`\r\n      );\r\n    }).join(\"\\n\\n\");\r\n  }\r\n\r\n  try {\r\n    const logId = crypto.randomUUID();\r\n    const logData = {\r\n      expert_id: expertId,\r\n      elevator_id: elevatorId || \"All\",\r\n      user_query: userQuery,\r\n      ai_response: aiResponseText,\r\n      status: \"completed\",\r\n      timestamp: new Date().toISOString(),\r\n      log_id: logId,\r\n    };\r\n\r\n    await axios.post(`${BACKEND_URL}/store_log`, logData);\r\n    console.log(`üü¢ Log stored successfully${elevatorId ? ` for Elevator ${elevatorId}` : \"\"}.`);\r\n    return true;\r\n\r\n  } catch (err) {\r\n    console.error(\"‚ùå Error saving log:\", err.response ? err.response.data : err.message);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ NEW: Conversational AI Chat via Ollama (/chat endpoint)\r\n * Sends conversation history to backend for natural, human-like responses.\r\n */\r\nexport const chatWithAI = async (messages) => {\r\n  try {\r\n    const res = await axios.post(`${BACKEND_URL}/chat`, { messages });\r\n    return res.data?.response || \"No response received from AI.\";\r\n  } catch (error) {\r\n    console.error(\"‚ùå Chat API error:\", error);\r\n    return \"AI is currently unavailable.\";\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}