{"ast":null,"code":"import axios from \"axios\";\n\n// --- CONFIGURATION ---\n// Change this to your backend‚Äôs URL if different (e.g., Flask running on port 8001)\nconst BACKEND_URL = \"http://localhost:8001\";\n// ---\n\n/**\r\n * Performs a vector search by calling the backend's /knowledge_search endpoint.\r\n * Supports optional filtering by elevator ID.\r\n * @param {string} query - The technician's query or problem description.\r\n * @param {string} elevatorId - (Optional) Elevator ID to filter results.\r\n * @returns {Promise<Array<object>>} - A promise that resolves to an array of result objects.\r\n */\nexport const searchKnowledge = async (query, elevatorId = \"\") => {\n  try {\n    var _res$data;\n    // Construct the base URL\n    let url = `${BACKEND_URL}/knowledge_search?query=${encodeURIComponent(query)}&n_results=3`;\n\n    // Add optional elevator filter only if provided\n    if (elevatorId && elevatorId.trim() !== \"\") {\n      url += `&elevator_id=${encodeURIComponent(elevatorId.trim())}`;\n    }\n    const res = await axios.get(url);\n    const results = ((_res$data = res.data) === null || _res$data === void 0 ? void 0 : _res$data.results) || [];\n    if (results.length > 0) {\n      console.log(`üîç Found ${results.length} results${elevatorId ? ` for Elevator ${elevatorId}` : \"\"}.`);\n    } else {\n      console.log(\"‚ÑπÔ∏è No relevant results found.\");\n    }\n    return results;\n  } catch (error) {\n    console.error(\"‚ùå Error fetching knowledge from backend:\", error);\n\n    // Return a safe structured fallback if backend is unreachable\n    return [{\n      problem: \"Error\",\n      cause: \"Could not reach knowledge base or backend service.\",\n      steps: error.message || \"Server unreachable or misconfigured.\",\n      distance: 1.0\n    }];\n  }\n};\n\n/**\r\n * Stores a chat or search log entry in the backend database.\r\n * This calls the Flask /store_log endpoint.\r\n * Includes optional elevator_id.\r\n * @param {string} expertId - Technician or expert‚Äôs unique ID.\r\n * @param {string} userQuery - The technician‚Äôs input query.\r\n * @param {Array<object>} searchResults - The structured array of AI search results.\r\n * @param {string} elevatorId - (Optional) Elevator ID related to the query.\r\n * @returns {Promise<boolean>} - True if saved successfully, false otherwise.\r\n */\nexport async function persistLog(expertId, userQuery, searchResults, elevatorId = \"\") {\n  if (!expertId) {\n    console.warn(\"‚ö†Ô∏è No expert ID provided ‚Äî skipping log persistence.\");\n    return false;\n  }\n\n  // Convert search results into a readable string format\n  let aiResponseText = \"No relevant steps found.\";\n  if (searchResults && searchResults.length > 0) {\n    aiResponseText = searchResults.map((r, i) => {\n      const distance = parseFloat(r.distance);\n      const distanceText = !isNaN(distance) ? distance.toFixed(4) : \"N/A\";\n      return `--- Match ${i + 1} (Distance: ${distanceText}) ---\\n` + `Problem: ${r.problem}\\n` + `Cause: ${r.cause}\\n` + `Steps: ${r.steps}`;\n    }).join(\"\\n\\n\");\n  }\n  try {\n    // Unique log identifier\n    const logId = crypto.randomUUID();\n\n    // Structured payload for the backend\n    const logData = {\n      expert_id: expertId,\n      elevator_id: elevatorId || \"All\",\n      // default if not provided\n      user_query: userQuery,\n      ai_response: aiResponseText,\n      status: \"completed\",\n      timestamp: new Date().toISOString(),\n      log_id: logId\n    };\n\n    // Send to Flask backend\n    await axios.post(`${BACKEND_URL}/store_log`, logData);\n    console.log(`üü¢ Log stored successfully${elevatorId ? ` for Elevator ${elevatorId}` : \"\"}.`);\n    return true;\n  } catch (err) {\n    console.error(\"‚ùå Error saving log:\", err.response ? err.response.data : err.message);\n    return false;\n  }\n}","map":{"version":3,"names":["axios","BACKEND_URL","searchKnowledge","query","elevatorId","_res$data","url","encodeURIComponent","trim","res","get","results","data","length","console","log","error","problem","cause","steps","message","distance","persistLog","expertId","userQuery","searchResults","warn","aiResponseText","map","r","i","parseFloat","distanceText","isNaN","toFixed","join","logId","crypto","randomUUID","logData","expert_id","elevator_id","user_query","ai_response","status","timestamp","Date","toISOString","log_id","post","err","response"],"sources":["C:/Users/Hari/OneDrive/Desktop/elevator_project/frontend/src/api.js"],"sourcesContent":["import axios from \"axios\";\r\n\r\n// --- CONFIGURATION ---\r\n// Change this to your backend‚Äôs URL if different (e.g., Flask running on port 8001)\r\nconst BACKEND_URL = \"http://localhost:8001\";\r\n// ---\r\n\r\n/**\r\n * Performs a vector search by calling the backend's /knowledge_search endpoint.\r\n * Supports optional filtering by elevator ID.\r\n * @param {string} query - The technician's query or problem description.\r\n * @param {string} elevatorId - (Optional) Elevator ID to filter results.\r\n * @returns {Promise<Array<object>>} - A promise that resolves to an array of result objects.\r\n */\r\nexport const searchKnowledge = async (query, elevatorId = \"\") => {\r\n    try {\r\n        // Construct the base URL\r\n        let url = `${BACKEND_URL}/knowledge_search?query=${encodeURIComponent(query)}&n_results=3`;\r\n\r\n        // Add optional elevator filter only if provided\r\n        if (elevatorId && elevatorId.trim() !== \"\") {\r\n            url += `&elevator_id=${encodeURIComponent(elevatorId.trim())}`;\r\n        }\r\n\r\n        const res = await axios.get(url);\r\n        const results = res.data?.results || [];\r\n\r\n        if (results.length > 0) {\r\n            console.log(`üîç Found ${results.length} results${elevatorId ? ` for Elevator ${elevatorId}` : \"\"}.`);\r\n        } else {\r\n            console.log(\"‚ÑπÔ∏è No relevant results found.\");\r\n        }\r\n\r\n        return results;\r\n\r\n    } catch (error) {\r\n        console.error(\"‚ùå Error fetching knowledge from backend:\", error);\r\n\r\n        // Return a safe structured fallback if backend is unreachable\r\n        return [{\r\n            problem: \"Error\",\r\n            cause: \"Could not reach knowledge base or backend service.\",\r\n            steps: error.message || \"Server unreachable or misconfigured.\",\r\n            distance: 1.0\r\n        }];\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * Stores a chat or search log entry in the backend database.\r\n * This calls the Flask /store_log endpoint.\r\n * Includes optional elevator_id.\r\n * @param {string} expertId - Technician or expert‚Äôs unique ID.\r\n * @param {string} userQuery - The technician‚Äôs input query.\r\n * @param {Array<object>} searchResults - The structured array of AI search results.\r\n * @param {string} elevatorId - (Optional) Elevator ID related to the query.\r\n * @returns {Promise<boolean>} - True if saved successfully, false otherwise.\r\n */\r\nexport async function persistLog(expertId, userQuery, searchResults, elevatorId = \"\") {\r\n    if (!expertId) {\r\n        console.warn(\"‚ö†Ô∏è No expert ID provided ‚Äî skipping log persistence.\");\r\n        return false;\r\n    }\r\n\r\n    // Convert search results into a readable string format\r\n    let aiResponseText = \"No relevant steps found.\";\r\n    if (searchResults && searchResults.length > 0) {\r\n        aiResponseText = searchResults.map((r, i) => {\r\n            const distance = parseFloat(r.distance);\r\n            const distanceText = !isNaN(distance) ? distance.toFixed(4) : \"N/A\";\r\n            return (\r\n                `--- Match ${i + 1} (Distance: ${distanceText}) ---\\n` +\r\n                `Problem: ${r.problem}\\n` +\r\n                `Cause: ${r.cause}\\n` +\r\n                `Steps: ${r.steps}`\r\n            );\r\n        }).join(\"\\n\\n\");\r\n    }\r\n\r\n    try {\r\n        // Unique log identifier\r\n        const logId = crypto.randomUUID();\r\n\r\n        // Structured payload for the backend\r\n        const logData = {\r\n            expert_id: expertId,\r\n            elevator_id: elevatorId || \"All\", // default if not provided\r\n            user_query: userQuery,\r\n            ai_response: aiResponseText,\r\n            status: \"completed\",\r\n            timestamp: new Date().toISOString(),\r\n            log_id: logId,\r\n        };\r\n\r\n        // Send to Flask backend\r\n        await axios.post(`${BACKEND_URL}/store_log`, logData);\r\n\r\n        console.log(`üü¢ Log stored successfully${elevatorId ? ` for Elevator ${elevatorId}` : \"\"}.`);\r\n        return true;\r\n\r\n    } catch (err) {\r\n        console.error(\"‚ùå Error saving log:\", err.response ? err.response.data : err.message);\r\n        return false;\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}